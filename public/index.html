<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Table Generator with Download</title>
    <style>
        table {
            border-collapse: collapse;
            margin: 10px;
        }
        th, td {
            border: 1px solid black;
            padding: 5px;
            text-align: center;
        }
    </style>
</head>
<body>

    <h2>Random table ID</h2>
    <label for="primaryTableIdInput">Primary Table ID:</label>
    <input type="number" id="primaryTableIdInput" name="primaryTableIdInput" min="1" value="1">


    <h2>Dynamic Table Generator</h2>

    <label for="initialRows">Number of Rows:</label>
    <input type="number" id="initialRows" name="initialRows" min="1" max="10" value="3">
    <label for="initialCols">Number of Columns:</label>
    <input type="number" id="initialCols" name="initialCols" min="1" max="30" value="10">
    <button onclick="generateInitialTable()">Create Initial Table</button><br><br>

    <div id="initialTableContainer"></div>

    <h3>Random Secondary Tables Generator</h3>
    <label for="randomRows">Random Table Rows:</label>
    <input type="number" id="randomRows" name="randomRows" min="1" value="3">
    <label for="randomCols">Random Table Columns:</label>
    <input type="number" id="randomCols" name="randomCols" min="1" value="3">
    <label for="numTables">Number of Random Tables:</label>
    <input type="number" id="numTables" name="numTables" min="1" value="5">
    <button onclick="generateRandomTables()">Generate Random Tables</button>
    <button onclick="downloadPDF()">Download PDF</button>
    <button onclick="downloadDoc()">Download DOC</button>
    <button onclick="saveSecondaryTables()">Save Secondary Tables</button>
    <button onclick="retrieveSecondaryTables()">Retrieve Secondary Tables</button>
    
   

    <h3>Randomly Generated Tables</h3>
    <div id="randomTablesContainer"></div>

   

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.0.1/docx.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>

    <script>
        let initialTable = [];
        let excludedRows = new Set();
        let excludedCols = new Set();
        let randomTablesData = [];

        // Function to generate the initial table with input fields and checkboxes for row/column removal
        function generateInitialTable() {
            const numRows = document.getElementById('initialRows').value;
            const numCols = document.getElementById('initialCols').value;
            initialTable = [];

            let tableContainer = document.getElementById('initialTableContainer');
            tableContainer.innerHTML = ''; // Clear previous table

            let table = document.createElement('table');

            // Generate the column checkboxes row
            let colCheckboxRow = document.createElement('tr');
            colCheckboxRow.appendChild(document.createElement('td')); // Empty cell at the start for row checkboxes
            for (let j = 0; j < numCols; j++) {
                let colCheckboxCell = document.createElement('td');
                let colCheckbox = document.createElement('input');
                colCheckbox.type = 'checkbox';
                colCheckbox.id = `removeCol${j}`;
                colCheckboxCell.appendChild(colCheckbox);
                colCheckboxRow.appendChild(colCheckboxCell);
            }
            table.appendChild(colCheckboxRow);

            // Generate the table with input fields and row checkboxes
            for (let i = 0; i < numRows; i++) {
                let row = [];
                let tableRow = document.createElement('tr');

                // Row checkbox for removal
                let rowCheckboxCell = document.createElement('td');
                let rowCheckbox = document.createElement('input');
                rowCheckbox.type = 'checkbox';
                rowCheckbox.id = `removeRow${i}`;
                rowCheckboxCell.appendChild(rowCheckbox);
                tableRow.appendChild(rowCheckboxCell);

                for (let j = 0; j < numCols; j++) {
                    let cell = document.createElement('td');
                    let input = document.createElement('input');
                    input.type = 'text';
                    input.id = `R${i}C${j}`; // Unique ID for each cell
                    input.placeholder = `R${i+1}C${j+1}`;
                    row.push(input.id);
                    cell.appendChild(input);
                    tableRow.appendChild(cell);
                }
                initialTable.push(row);
                table.appendChild(tableRow);
            }
            tableContainer.appendChild(table);
        }

        // Function to get the values from the initial table, skipping removed rows/columns
        function getInitialTableValues() {
            let tableValues = [];
            for (let i = 0; i < initialTable.length; i++) {
                if (document.getElementById(`removeRow${i}`).checked) {
                    excludedRows.add(i);
                    continue;
                }
                let rowValues = [];
                for (let j = 0; j < initialTable[i].length; j++) {
                    if (document.getElementById(`removeCol${j}`).checked) {
                        excludedCols.add(j);
                        continue;
                    }
                    let cellValue = document.getElementById(initialTable[i][j]).value || initialTable[i][j];
                    rowValues.push(cellValue);
                }
                tableValues.push(rowValues);
            }
            return tableValues;
        }

        // Function to generate random tables with random rows but the same columns
function generateRandomTables() {
    const randomRows = parseInt(document.getElementById('randomRows').value);
    const numTables = parseInt(document.getElementById('numTables').value);
    const initialTableValues = getInitialTableValues();  // Get the values from the initial table
    const totalRows = initialTableValues.length;  // Number of rows in the primary table

    let randomTablesContainer = document.getElementById('randomTablesContainer');
    randomTablesContainer.innerHTML = ''; // Clear previous tables
    randomTablesData = []; // Reset random tables data

    for (let i = 0; i < numTables; i++) {
        let selectedRows = getRandomSelection(totalRows, randomRows, excludedRows);  // Random rows

        let randomTable = [];
        for (let row of selectedRows) {
            randomTable.push([...initialTableValues[row]]);  // Keep the columns intact
        }

        randomTablesData.push(randomTable);  // Store the table data
        displayTable(randomTable, randomTablesContainer);  // Display the table
    }
}

// Helper function to generate unique random row indices, excluding certain rows
function getRandomSelection(total, count, excludedSet) {
    let selected = [];
    while (selected.length < count) {
        let randomIndex = Math.floor(Math.random() * total);
        if (!selected.includes(randomIndex) && !excludedSet.has(randomIndex)) {
            selected.push(randomIndex);
        }
    }
    return selected;
}

        // Helper function to display the generated tables
        function displayTable(tableData, container) {
            let table = document.createElement('table');
            for (let rowIndex = 0; rowIndex < tableData.length; rowIndex++) {
                let tableRow = document.createElement('tr');
                for (let colIndex = 0; colIndex < tableData[rowIndex].length; colIndex++) {
                    let td = document.createElement('td');
                    td.innerHTML = tableData[rowIndex][colIndex];
                    td.id = `randomTable${rowIndex}${colIndex}`; // Assign unique ID for random table cells
                    tableRow.appendChild(td);
                }
                table.appendChild(tableRow);
            }
            container.appendChild(table);
        }

        // Function to download the random tables as a PDF file with tables filling the page
        function downloadPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            let currentY = 10; // Start Y position

            randomTablesData.forEach((table, index) => {
                // Add a title for each random table
                doc.text(`Random Table ${index + 1}`, 10, currentY);

                // Use autoTable to add the table in a tabular format
                doc.autoTable({
                    startY: currentY + 10,  // Position below the title
                    body: table  // Pass the table data
                });

                currentY = doc.lastAutoTable.finalY + 20;  // Adjust Y position based on table height

                if (currentY >= 280) {  // If the Y position exceeds the page height
                    doc.addPage();  // Add a new page
                    currentY = 10;  // Reset Y position for the new page
                }
            });

            doc.save('random_tables.pdf');
        }

        // Function to download the random tables as a DOC file
        function downloadDoc() {
            const doc = new docx.Document({
                sections: [
                    {
                        properties: {},
                        children: randomTablesData.map((table, index) => {
                            return [
                                new docx.Paragraph({
                                    text: `Random Table ${index + 1}`,
                                    heading: docx.HeadingLevel.HEADING_2,
                                }),
                                new docx.Table({
                                    rows: table.map(row => new docx.TableRow({
                                        children: row.map(cell => new docx.TableCell({
                                            children: [new docx.Paragraph(cell.toString())]
                                        }))
                                    }))
                                }),
                                new docx.Paragraph({
                                    text: '',
                                    spacing: { before: 240, after: 240 }
                                })
                            ];
                        }).flat()
                    }
                ]
            });

            docx.Packer.toBlob(doc).then(blob => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = "random_tables.docx";
                a.click();
            });
        }

        
        // Function to save secondary tables
    async function saveSecondaryTables() {
    const secondaryTables = randomTablesData;
    const primaryTable = getInitialTableValues();
    const primaryTableId = parseInt(document.getElementById('primaryTableIdInput').value); // Assuming you have an input for primaryTableId
    
    console.log('Primary Table ID:', primaryTableId, typeof primaryTableId);
    console.log('Primary Table:', primaryTable)
    console.log('Secondary Tables:', secondaryTables),typeof("type",secondaryTables);

    try {
        const response = await fetch('https://random-backend-pzys.onrender.com/save-secondary-tables', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ primaryTableId,primaryTable, secondaryTables }),
        });

        console.log('Raw Response:', response);

        // If response is not okay, throw an error
        if (!response.ok) {
            //throw new Error(`HTTP error! Status: ${response.status}`);
            const errorData = await response.json();
            if (response.status === 401 && errorData.message) {
                alert(`Error: ${errorData.message}`); // Show the error message in an alert
            } else {
                alert('Error saving secondary tables.');
            }
            return;
        }

        // Parse the response JSON if there is a body
        const contentLength = response.headers.get('Content-Length');
        let data = {};
        if (contentLength && parseInt(contentLength) > 0) {
            data = await response.json();
        }
        
        console.log('Parsed JSON Data:', data);  // Log the parsed JSON data from the server
        alert('Secondary tables saved successfully!');

    } catch (error) {
        console.error('Error saving tables:', error);
        alert('Error saving secondary tables.');
    }
}

// Function to retrieve secondary tables from the server
//let initialTable = []; // Store the primary table values for tracking


//remove from the secondary table
function retrieveSecondaryTables() {
    const primaryTableId = parseInt(document.getElementById('primaryTableIdInput').value);

    fetch(`https://random-backend-pzys.onrender.com/retrieve-secondary-tables/${primaryTableId}`)
        .then(response => response.json())
        .then(data => {
            const primaryTable = data.primary;
            const retrievedTables = data.secondary;

            let randomTablesContainer = document.getElementById('randomTablesContainer');
            randomTablesContainer.innerHTML = ''; // Clear previous tables

            // Display the primary table
            if (primaryTable && primaryTable.length > 0) {
                const primaryTableName = `Primary Table (ID: ${primaryTableId})`;
                displayTableName(primaryTableName, randomTablesContainer);
                displayPrimaryTableWithCheckboxes(primaryTable, randomTablesContainer, retrievedTables);
            }

            // Display each secondary table with name
            if (Array.isArray(retrievedTables)) {
                retrievedTables.forEach((table, index) => {
                    const secondaryTableName = `Secondary Table ${index + 1}`;
                    displayTableName(secondaryTableName, randomTablesContainer);
                    displayTable(table, randomTablesContainer, `secondaryTable-${index}`);
                });
            } else {
                console.warn('No secondary tables found.');
            }

            // Add PDF download button
            addDownloadPDFButton(primaryTable, retrievedTables);

            alert('Tables retrieved successfully!');
        })
        .catch((error) => {
            console.error('Error retrieving tables:', error);
            alert('Error retrieving secondary tables.');
        });
}

// Function to add a download PDF button
function addDownloadPDFButton(primaryTable, secondaryTables) {
    const container = document.getElementById('randomTablesContainer');
    const downloadButton = document.createElement('button');
    downloadButton.innerText = 'Download Visible Tables as PDF';
    downloadButton.onclick = () => downloadPDF(primaryTable, secondaryTables);
    container.appendChild(downloadButton);
}

// Function to download visible tables as PDF
function downloadPDF(primaryTable, secondaryTables) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();

    let visibleSecondaryTables = [];

    // Add primary table to PDF
    doc.text("Primary Table:", 10, 10);
    addTableToPDF(doc, primaryTable, 20);

    // Add each visible secondary table to PDF
    let yPosition = 40;
    secondaryTables.forEach((table, index) => {
        const tableId = `secondaryTable-${index}`;
        const tableElement = document.getElementById(tableId);

        if (tableElement && tableElement.style.display !== 'none') {
            visibleSecondaryTables.push(table);
            doc.text(`Secondary Table ${index + 1}:`, 10, yPosition);
            yPosition += 10;
            yPosition = addTableToPDF(doc, table, yPosition);
        }
    });

    // Save the PDF file
    doc.save('visible_tables.pdf');
}

// Function to add a table to the PDF
function addTableToPDF(doc, table, startY) {
    let yPosition = startY;

    table.forEach((row) => {
        const rowText = row.join('   '); // Format each row
        doc.text(rowText, 10, yPosition);
        yPosition += 10; // Move to the next line
    });

    return yPosition;
}

// Function to display the primary table with checkboxes
function displayPrimaryTableWithCheckboxes(table, container, secondaryTables) {
    const tableElement = document.createElement('table');
    tableElement.classList.add('primary-table');

    // Create a header row for checkboxes
    const headerRow = document.createElement('tr');
    const checkboxHeaderCell = document.createElement('th');
    checkboxHeaderCell.innerText = 'Select';
    headerRow.appendChild(checkboxHeaderCell);
    tableElement.appendChild(headerRow);

    table.forEach((row, rowIndex) => {
        const rowElement = document.createElement('tr');

        // Create checkbox cell
        const checkboxCell = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';

        // Attach event listener for checkbox click
        checkbox.addEventListener('click', () => {
            highlightCorrespondingTables(row, secondaryTables, checkbox.checked);
        });

        checkboxCell.appendChild(checkbox);
        rowElement.appendChild(checkboxCell);

        // Create cells for the row
        row.forEach(cell => {
            const cellElement = document.createElement('td');
            cellElement.innerText = cell;
            rowElement.appendChild(cellElement);
        });
        
        tableElement.appendChild(rowElement);
    });

    container.appendChild(tableElement);
}

// Function to hide entire secondary tables based on primary row values
function highlightCorrespondingTables(primaryRow, secondaryTables, isChecked) {
    const primaryRowValues = primaryRow;

    secondaryTables.forEach((secondaryTable, secondaryIndex) => {
        const tableId = `secondaryTable-${secondaryIndex}`;
        const secondaryTableElement = document.getElementById(tableId);

        if (secondaryTableElement) {
            const containsMatchingRow = secondaryTable.some(secondaryRow => 
                primaryRowValues.every((value, index) => value === secondaryRow[index])
            );

            if (isChecked) {
                if (containsMatchingRow) {
                    secondaryTableElement.style.display = 'none'; // Hide the table
                }
            } else {
                secondaryTableElement.style.display = ''; // Show the table
            }
        }
    });
}

// Function to display a secondary table
function displayTable(table, container, tableId) {
    const tableElement = document.createElement('table');
    tableElement.id = tableId;

    table.forEach(row => {
        const rowElement = document.createElement('tr');
        row.forEach(cell => {
            const cellElement = document.createElement('td');
            cellElement.innerText = cell;
            rowElement.appendChild(cellElement);
        });
        tableElement.appendChild(rowElement);
    });

    container.appendChild(tableElement);
}

// Function to display table names
function displayTableName(tableName, container) {
    const tableNameElement = document.createElement('h3');
    tableNameElement.innerText = tableName;
    container.appendChild(tableNameElement);
}


    </script>
</body>
</html>
